---
phase: 01-foundation
plan: "06"
type: execute
wave: 6
depends_on:
  - "01-03"
  - "01-04"
files_modified:
  - "lib/organizations/org-context.ts"
  - "lib/organizations/index.ts"
  - "lib/query-keys.ts"
  - "lib/errors/types.ts"
  - "app/(dashboard)/dashboard/page.tsx"
  - "app/(dashboard)/settings/page.tsx"
autonomous: true
must_haves:
  truths:
    - "getOrgContext() returns userId, organizationId, and role for authenticated users"
    - "Protected routes automatically redirect to login when unauthenticated"
    - "Query keys are consistent across all data fetching"
    - "Error types are standardized for cross-phase consistency"
  artifacts:
    - path: "lib/organizations/org-context.ts"
      provides: "getOrgContext() function for organization isolation"
    - path: "lib/query-keys.ts"
      provides: "Consistent query key constants for React Query"
    - path: "lib/errors/types.ts"
      provides: "Standardized error types for all phases"
  key_links:
    - from: "lib/organizations/org-context.ts"
      to: "lib/supabase/server.ts"
      via: "Supabase auth.getUser() for user identification"
    - from: "lib/organizations/org-context.ts"
      to: "supabase/migrations/001_initial_schema.sql"
      via: "profiles table for organization_id and role"
    - from: "lib/query-keys.ts"
      to: "lib/repositories/*.repository.ts"
      via: "Consistent invalidation patterns with query keys"
provides_interface:
  - name: getOrgContext
    type: function
    description: "Returns userId, organizationId, role for current authenticated user"
  - name: OrgContext
    type: interface
    description: "Type definition for organization context object"
  - name: queryKeys
    type: constant
    description: "React Query keys for dashboard, metrics, alerts, and AI features"
  - name: AppError
    type: interface
    description: "Standard error type with code, message, context, and retryable flag"
  - name: ERROR_CODES
    type: constant
    description: "Enum-like constants for error code identification"
assumes_from:
  - phase: 1
    interface: createServerClient
    usage: "Retrieves authenticated user and profile for org context"
    interface: Profile
    usage: "Type definition for profile data including organization_id and role"
---

<objective>
Create the organization context system and shared utilities that downstream phases depend on. This wave implements getOrgContext() for multi-tenant isolation, standardized query keys for React Query, and common error types for consistent error handling across all phases.

Purpose: Foundation for organization-scoped data access used by Phases 2, 3, 4
Output: Organization context, query keys, and error types
</objective>

<execution_context>
{file:~/.config/workspace/.config/opencode/gsd/workflows/execute-plan.md}
{file:~/.config/workspace/.config/opencode/gsd/templates/summary.md}
</execution_context>

<context>
@.planning/phases/01-FOUNDATION/01-RESEARCH.md

# Provides interface from research
# - getOrgContext() - Required by Phases 2, 3
# - Shared error types - Required by Phases 2, 3, 4
# - Shared query key constants - Required by Phases 3, 4
# - Table names enum - Required by Phases 2, 3
# - TimeSeriesDataPoint interface - Required by Phase 4
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create organization context function</name>
  <files>lib/organizations/org-context.ts</files>
  <action>
    Create `lib/organizations/org-context.ts` with getOrgContext() function.

    This is a CRITICAL function used by all downstream phases for multi-tenant isolation.

    From RESEARCH.md with full implementation:
    ```typescript
    import { createServerClient } from '@/lib/supabase/server'

    export interface OrgContext {
      userId: string
      organizationId: string
      role: 'admin' | 'member'
    }

    /**
     * Retrieves the current user's organization context.
     * This function is required by Phase 2 (AI Query Engine) for multi-tenant isolation
     * and Phase 3 (Dashboard UI) for data fetching.
     *
     * @throws {Error} 'Unauthorized' - If user is not authenticated
     * @throws {Error} 'No organization context' - If user has no organization
     * @returns {Promise<OrgContext>} The user's context including user ID, organization ID, and role
     *
     * @example
     * const { userId, organizationId, role } = await getOrgContext()
     * // Used in Phase 2: AI query functions use orgId for RLS enforcement
     * // Used in Phase 3: Dashboard queries filter by organizationId
     */
    export async function getOrgContext(): Promise<OrgContext> {
      const supabase = await createServerClient()

      const { data: { user }, error: authError } = await supabase.auth.getUser()

      if (authError || !user) {
        throw new Error('Unauthorized')
      }

      const { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('organization_id, role')
        .eq('id', user.id)
        .single()

      if (profileError || !profile?.organization_id) {
        throw new Error('No organization context')
      }

      return {
        userId: user.id,
        organizationId: profile.organization_id,
        role: profile.role as 'admin' | 'member',
      }
    }

    /**
     * Simplified version that returns null instead of throwing
     */
    export async function getOrgContextOrNull(): Promise<OrgContext | null> {
      try {
        return await getOrgContext()
      } catch {
        return null
      }
    }
    ```

    IMPORTANT: This function MUST be called in Server Components only. For client components, pass data through props.
  </action>
  <verify>
    cat lib/organizations/org-context.ts | grep -c "export async function getOrgContext"
    cat lib/organizations/org-context.ts | grep -c "organization_id"
  </verify>
  <done>
    "lib/organizations/org-context.ts created with getOrgContext() for multi-tenant isolation"
  </done>
</task>

<task type="auto">
  <name>Task 2: Create organization index export</name>
  <files>lib/organizations/index.ts</files>
  <action>
    Create `lib/organizations/index.ts` as the main export point.

    ```typescript
    export { getOrgContext, getOrgContextOrNull, type OrgContext } from './org-context'
    ```
  </action>
  <verify>
    cat lib/organizations/index.ts | grep -c "export"
  </verify>
  <done>
    "lib/organizations/index.ts created as export point for organization utilities"
  </done>
</task>

<task type="auto">
  <name>Task 3: Create shared query key constants</name>
  <files>lib/query-keys.ts</files>
  <action>
    Create `lib/query-keys.ts` with consistent React Query keys.

    From RESEARCH.md:
    ```typescript
    export const queryKeys = {
      // Dashboard
      dashboard: ['dashboard'] as const,
      dashboardMetrics: (orgId: string) => ['dashboard', 'metrics', orgId] as const,
      dashboardAlerts: (orgId: string) => ['dashboard', 'alerts', orgId] as const,

      // Organizations
      organization: (orgId: string) => ['organization', orgId] as const,
      organizationMembers: (orgId: string) => ['organization', orgId, 'members'] as const,

      // Customers
      customers: (orgId: string) => ['customers', orgId] as const,
      customer: (orgId: string, customerId: string) => ['customers', orgId, customerId] as const,
      customerStats: (orgId: string) => ['customers', orgId, 'stats'] as const,

      // Revenue
      revenue: (orgId: string) => ['revenue', orgId] as const,
      revenueTrend: (orgId: string, months: number) => ['revenue', orgId, 'trend', months] as const,
      revenueByCategory: (orgId: string) => ['revenue', orgId, 'category'] as const,

      // Activities
      activities: (orgId: string) => ['activities', orgId] as const,
      activityStats: (orgId: string) => ['activities', orgId, 'stats'] as const,

      // AI
      ai: {
        queries: (orgId: string) => ['ai', 'queries', orgId] as const,
        charts: (orgId: string) => ['ai', 'charts', orgId] as const,
        usage: (orgId: string) => ['ai', 'usage', orgId] as const,
      },

      // User
      userProfile: ['user', 'profile'] as const,
      userPreferences: ['user', 'preferences'] as const,
    } as const
    ```

    These keys ensure consistent cache invalidation across all data fetching.
  </action>
  <verify>
    cat lib/query-keys.ts | grep -c "as const"
    cat lib/query-keys.ts | grep -c "orgId"
  </verify>
  <done>
    "lib/query-keys.ts created with organization-scoped query keys"
  </done>
</task>

<task type="auto">
  <name>Task 4: Create shared error types</name>
  <files>lib/errors/types.ts</files>
  <action>
    Create `lib/errors/types.ts` with standardized error handling.

    From RESEARCH.md:
    ```typescript
    export interface AppError {
      code: string
      message: string
      context?: Record<string, unknown>
      retryable: boolean
    }

    export const ERROR_CODES = {
      UNAUTHORIZED: 'UNAUTHORIZED',
      NOT_FOUND: 'NOT_FOUND',
      VALIDATION_ERROR: 'VALIDATION_ERROR',
      RATE_LIMITED: 'RATE_LIMITED',
      QUOTA_EXCEEDED: 'QUOTA_EXCEEDED',
      DATABASE_ERROR: 'DATABASE_ERROR',
      AI_ERROR: 'AI_ERROR',
      UNKNOWN: 'UNKNOWN',
    } as const

    export type ErrorCode = typeof ERROR_CODES[keyof typeof ERROR_CODES]

    /**
     * Create a standardized error object
     */
    export function createError(
      code: ErrorCode,
      message: string,
      options?: {
        context?: Record<string, unknown>
        retryable?: boolean
      }
    ): AppError {
      return {
        code,
        message,
        context: options?.context,
        retryable: options?.retryable ?? false,
      }
    }

    /**
     * Wrap a function to catch and standardize errors
     */
    export function withErrorHandling<T, Args extends unknown[]>(
      fn: (...args: Args) => Promise<T>,
      errorHandler?: (error: unknown) => AppError
    ): (...args: Args) => Promise<T> {
      return async (...args: Args) => {
        try {
          return await fn(...args)
        } catch (error) {
          if (errorHandler) {
            throw errorHandler(error)
          }
          throw createError(
            ERROR_CODES.UNKNOWN,
            error instanceof Error ? error.message : 'An unknown error occurred'
          )
        }
      }
    }
    ```
  </action>
  <verify>
    cat lib/errors/types.ts | grep -c "export"
    cat lib/errors/types.ts | grep -c "ERROR_CODES"
  </verify>
  <done>
    "lib/errors/types.ts created with standardized error codes and helper functions"
  </done>
</task>

<task type="auto">
  <name>Task 5: Create table names enum</name>
  <files>lib/db/table-names.ts</files>
  <action>
    Create `lib/db/table-names.ts` for consistent table reference.

    From RESEARCH.md:
    ```typescript
    export const TABLE_NAMES = {
      ORGANIZATIONS: 'organizations',
      PROFILES: 'profiles',
      CUSTOMERS: 'customers',
      REVENUE: 'revenue',
      ACTIVITIES: 'activities',
      AUDIT_LOGS: 'audit_logs',
      AI_USAGE_LOG: 'ai_usage_log',
      USER_PREFERENCES: 'user_preferences',
    } as const

    export type TableName = typeof TABLE_NAMES[keyof typeof TABLE_NAMES]
    ```

    This ensures table names are referenced consistently throughout the codebase.
  </action>
  <verify>
    cat lib/db/table-names.ts | grep -c "export const TABLE_NAMES"
  </verify>
  <done>
    "lib/db/table-names.ts created with table name constants"
  </done>
</task>

<task type="auto">
  <name>Task 6: Create TimeSeriesDataPoint interface</name>
  <files>lib/types/time-series.ts</files>
  <action>
    Create `lib/types/time-series.ts` with time series data structures.

    From RESEARCH.md:
    ```typescript
    export interface TimeSeriesDataPoint {
      timestamp: string // ISO 8601 format for cross-phase consistency
      value: number
    }

    export interface MetricDataPoint {
      metricName: string
      currentValue: number
      mean: number
      standardDeviation: number
      zScore: number
      timestamp: string
    }

    export interface ChartDataPoint {
      label: string
      value: number
      secondaryValue?: number
      color?: string
    }
    ```

    This will be used by Phase 4 for real-time updates and anomaly detection.
  </action>
  <verify>
    cat lib/types/time-series.ts | grep -c "export interface"
  </verify>
  <done>
    "lib/types/time-series.ts created with time series data structures"
  </done>
</task>

<task type="auto">
  <name>Task 7: Create example protected dashboard page</name>
  <files>app/(dashboard)/dashboard/page.tsx</files>
  <action>
    Create `app/(dashboard)/dashboard/page.tsx` demonstrating org context usage.

    This page serves as a template for protected pages using getOrgContext():
    ```typescript
    import { getOrgContext } from '@/lib/organizations/org-context'
    import { getCustomerStats, getRevenueTotals, getRecentActivityCount } from '@/lib/repositories'

    export default async function DashboardPage() {
      const { organizationId } = await getOrgContext()

      // Fetch dashboard data in parallel
      const [customerStats, revenueTotals, activityCount] = await Promise.all([
        getCustomerStats(organizationId),
        getRevenueTotals(organizationId),
        getRecentActivityCount(organizationId, 7),
      ])

      return (
        <div className="space-y-6">
          <h1 className="text-3xl font-bold">Dashboard</h1>

          <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div className="bg-white p-6 rounded-lg shadow">
              <h2 className="text-lg font-medium text-gray-900">Total Revenue</h2>
              <p className="text-3xl font-bold mt-2">
                ${revenueTotals?.total_revenue?.toLocaleString() ?? '0'}
              </p>
              <p className="text-sm text-gray-500 mt-1">
                {revenueTotals?.transaction_count ?? 0} transactions
              </p>
            </div>

            <div className="bg-white p-6 rounded-lg shadow">
              <h2 className="text-lg font-medium text-gray-900">Customers</h2>
              <p className="text-3xl font-bold mt-2">
                {customerStats?.total_customers ?? 0}
              </p>
              <p className="text-sm text-green-600 mt-1">
                {customerStats?.active_customers ?? 0} active
              </p>
            </div>

            <div className="bg-white p-6 rounded-lg shadow">
              <h2 className="text-lg font-medium text-gray-900">Recent Activity</h2>
              <p className="text-3xl font-bold mt-2">
                {activityCount?.count ?? 0}
              </p>
              <p className="text-sm text-gray-500 mt-1">Last 7 days</p>
            </div>
          </div>
        </div>
      )
    }
    ```
  </action>
  <verify>
    cat app/\(dashboard\)/dashboard/page.tsx | grep -c "getOrgContext"
    cat app/\(dashboard\)/dashboard/page.tsx | grep -c "await get"
  </verify>
  <done>
    "Dashboard page created as template for protected routes with org context"
  </done>
</task>

</tasks>

<verification>
Verify all Phase 1 provides interfaces:
```bash
# Check org context
grep -r "getOrgContext" lib/ --include="*.ts" | wc -l
# Expected: 5+ references

# Check query keys
grep -r "queryKeys" lib/ --include="*.ts" | wc -l
# Expected: 3+ references

# Check error types
grep -r "ERROR_CODES" lib/ --include="*.ts" | wc -l
# Expected: 3+ references

# TypeScript compilation
npx tsc --noEmit --strict
# Expected: No errors
```
</verification>

<success_criteria>
- [ ] getOrgContext() returns userId, organizationId, role for authenticated users
- [ ] Unauthorized users are redirected to login
- [ ] Query keys are organization-scoped for proper cache isolation
- [ ] Error types are standardized with ERROR_CODES constants
- [ ] Table names are referenced consistently via TABLE_NAMES
- [ ] Time series data structures are defined for Phase 4
- [ ] Dashboard page demonstrates protected route pattern
- [ ] TypeScript strict mode passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-FOUNDATION/01-06-SUMMARY.md`
</output>
