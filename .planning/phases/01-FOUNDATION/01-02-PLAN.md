---
phase: 01-foundation
plan: "02"
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - "supabase/migrations/001_initial_schema.sql"
  - "supabase/schema.sql"
  - "lib/db/types.ts"
autonomous: true
must_haves:
  truths:
    - "Database schema includes organizations, profiles, customers, revenue, activities tables"
    - "RLS is enabled on all tables with organization isolation"
    - "Role-based access policies exist for admin/member roles"
    - "Trigger-based audit logging is configured"
    - "Soft delete pattern is implemented on business tables"
  artifacts:
    - path: "supabase/migrations/001_initial_schema.sql"
      provides: "Initial database migration with all tables and RLS policies"
    - path: "supabase/schema.sql"
      provides: "Full schema reference for debugging and documentation"
    - path: "lib/db/types.ts"
      provides: "TypeScript interfaces matching database tables"
  key_links:
    - from: "supabase/migrations/001_initial_schema.sql"
      to: "auth.users"
      via: "profiles table foreign key constraint"
    - from: "supabase/migrations/001_initial_schema.sql"
      to: "organizations"
      via: "profiles.organization_id foreign key"
    - from: "supabase/migrations/001_initial_schema.sql"
      to: "RLS policies"
      via: "organization_id column for multi-tenant isolation"
provides_interface:
  - name: TABLE_NAMES
    type: constant
    description: "Enum-like object with all table names for cross-phase queries"
  - name: Database
    type: interface
    description: "Kysely Database interface with all table type definitions"
  - name: Organization
    type: type
    description: "Selectable Organization table row type"
  - name: Profile
    type: type
    description: "Selectable Profile table row type"
  - name: Customer
    type: type
    description: "Selectable Customer table row type"
  - name: Revenue
    type: type
    description: "Selectable Revenue table row type"
  - name: Activity
    type: type
    description: "Selectable Activity table row type"
assumes_from:
  - phase: 1
    interface: createServerClient
    usage: "Used in seed scripts to create initial organization and profile records"
---

<objective>
Create the database foundation with all required tables, Row Level Security policies, and type definitions. This wave implements multi-tenant isolation at the database level and establishes the schema that all subsequent phases depend on.

Purpose: Secure, type-safe database layer with organization isolation and audit logging
Output: Database migration file, schema documentation, and TypeScript type definitions
</objective>

<execution_context>
{file:~/.config/opencode/gsd/workflows/execute-plan.md}
{file:~/.config/opencode/gsd/templates/summary.md}
</execution_context>

<context>
@.planning/phases/01-FOUNDATION/01-RESEARCH.md
@.planning/phases/01-FOUNDATION/CONTEXT.md

# RLS patterns from research
# - Use (SELECT auth.uid()) wrapper for 94% performance improvement
# - Per-table policies with organization_id column
# - Role-based access (admin/member) enforced at DB level
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase migrations directory and initial migration</name>
  <files>supabase/migrations/001_initial_schema.sql</files>
  <action>
    Create `supabase/migrations/001_initial_schema.sql` with complete database schema.

    Include these tables in order (respecting foreign key dependencies):

    1. **organizations table** (required first - other tables reference it)
       - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
       - name: TEXT NOT NULL
       - slug: TEXT UNIQUE NOT NULL (for URL-friendly identification)
       - created_at: TIMESTAMPTZ DEFAULT NOW()
       - updated_at: TIMESTAMPTZ DEFAULT NOW()

    2. **profiles table** (links to auth.users)
       - id: TEXT PRIMARY KEY (references auth.users.id)
       - email: TEXT NOT NULL
       - full_name: TEXT
       - avatar_url: TEXT
       - organization_id: UUID REFERENCES organizations(id) ON DELETE SET NULL
       - role: TEXT NOT NULL CHECK (role IN ('admin', 'member'))
       - created_at: TIMESTAMPTZ DEFAULT NOW()
       - updated_at: TIMESTAMPTZ DEFAULT NOW()

    3. **customers table** (business data with soft delete)
       - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
       - organization_id: UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE
       - name: TEXT NOT NULL
       - email: TEXT
       - company: TEXT
       - industry: TEXT
       - total_revenue: NUMERIC(12, 2) DEFAULT 0
       - last_purchase_date: TIMESTAMPTZ
       - status: TEXT NOT NULL CHECK (status IN ('active', 'inactive', 'churned'))
       - deleted_at: TIMESTAMPTZ (soft delete column)
       - created_at: TIMESTAMPTZ DEFAULT NOW()
       - updated_at: TIMESTAMPTZ DEFAULT NOW()

    4. **revenue table** (financial data)
       - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
       - organization_id: UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE
       - customer_id: UUID REFERENCES customers(id) ON DELETE SET NULL
       - amount: NUMERIC(12, 2) NOT NULL
       - date: DATE NOT NULL
       - category: TEXT
       - description: TEXT
       - created_at: TIMESTAMPTZ DEFAULT NOW()

    5. **activities table** (event tracking with JSONB)
       - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
       - organization_id: UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE
       - type: TEXT NOT NULL CHECK (type IN ('signup', 'purchase', 'churn', 'login', 'export'))
       - customer_id: UUID REFERENCES customers(id) ON DELETE SET NULL
       - metadata: JSONB DEFAULT '{}'::jsonb
       - created_at: TIMESTAMPTZ DEFAULT NOW()

    6. **audit_logs table** (trigger-based tracking)
       - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
       - organization_id: UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE
       - user_id: UUID NOT NULL (references auth.users)
       - action: TEXT NOT NULL
       - table_name: TEXT NOT NULL
       - record_id: UUID
       - old_data: JSONB
       - new_data: JSONB
       - created_at: TIMESTAMPTZ DEFAULT NOW()

    7. **ai_usage_log table** (AI cost tracking)
       - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
       - user_id: UUID NOT NULL
       - organization_id: UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE
       - query_id: UUID NOT NULL
       - input_tokens: INTEGER NOT NULL DEFAULT 0
       - output_tokens: INTEGER NOT NULL DEFAULT 0
       - cost_usd: NUMERIC(10, 4) NOT NULL DEFAULT 0
       - model: TEXT NOT NULL
       - date: DATE NOT NULL
       - created_at: TIMESTAMPTZ DEFAULT NOW()

    8. **user_preferences table** (user settings)
       - user_id: TEXT PRIMARY KEY REFERENCES profiles(id) ON DELETE CASCADE
       - theme_preference: TEXT NOT NULL DEFAULT 'system' CHECK (theme_preference IN ('light', 'dark', 'system'))
       - updated_at: TIMESTAMPTZ DEFAULT NOW()
  </action>
  <verify>
    cat supabase/migrations/001_initial_schema.sql | grep -c "CREATE TABLE"
    cat supabase/migrations/001_initial_schema.sql | grep -c "organization_id"
  </verify>
  <done>
    "supabase/migrations/001_initial_schema.sql created with 8 tables and proper foreign key constraints"
  </done>
</task>

<task type="auto">
  <name>Task 2: Enable RLS and create organization isolation policies</name>
  <files>supabase/migrations/001_initial_schema.sql</files>
  <action>
    Add to the migration file: RLS enablement and organization isolation policies.

    **Enable RLS on all tables:**
    ```sql
    ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
    ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
    ALTER TABLE customers ENABLE ROW LEVEL SECURITY;
    ALTER TABLE revenue ENABLE ROW LEVEL SECURITY;
    ALTER TABLE activities ENABLE ROW LEVEL SECURITY;
    ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
    ALTER TABLE ai_usage_log ENABLE ROW LEVEL SECURITY;
    ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
    ```

    **Organizations table policies** (users see their own org):
    ```sql
    -- Users can view their organization
    CREATE POLICY "Users can view their organization"
      ON organizations FOR SELECT
      USING (
        id IN (SELECT organization_id FROM profiles WHERE id = auth.uid())
      );

    -- Admins can update their organization
    CREATE POLICY "Admins can update their organization"
      ON organizations FOR UPDATE
      USING (
        id IN (SELECT organization_id FROM profiles WHERE id = auth.uid() AND role = 'admin')
      )
      WITH CHECK (
        id IN (SELECT organization_id FROM profiles WHERE id = auth.uid() AND role = 'admin')
      );
    ```

    **Profiles table policies** (users see profiles in their org):
    ```sql
    -- Users can view profiles in their organization
    CREATE POLICY "Users can view profiles in org"
      ON profiles FOR SELECT
      USING (
        organization_id IN (SELECT organization_id FROM profiles WHERE id = auth.uid())
      );

    -- Admins can manage profiles
    CREATE POLICY "Admins can manage profiles"
      ON profiles FOR ALL
      USING (
        organization_id IN (SELECT organization_id FROM profiles WHERE id = auth.uid() AND role = 'admin')
      )
      WITH CHECK (
        organization_id IN (SELECT organization_id FROM profiles WHERE id = auth.uid() AND role = 'admin')
      );
    ```

    **Customers, Revenue, Activities policies** (org-scoped with soft delete):
    ```sql
    -- Users can view customers in org (excluding soft-deleted)
    CREATE POLICY "Users can view customers in org"
      ON customers FOR SELECT
      USING (
        organization_id IN (SELECT organization_id FROM profiles WHERE id = auth.uid())
        AND (deleted_at IS NULL OR deleted_at > NOW())
      );

    -- Admins can manage customers
    CREATE POLICY "Admins can manage customers"
      ON customers FOR ALL
      USING (
        organization_id IN (SELECT organization_id FROM profiles WHERE id = auth.uid() AND role = 'admin')
      )
      WITH CHECK (
        organization_id IN (SELECT organization_id FROM profiles WHERE id = auth.uid() AND role = 'admin')
      );
    ```

    Repeat similar policies for revenue and activities tables.
  </action>
  <verify>
    cat supabase/migrations/001_initial_schema.sql | grep -c "ENABLE ROW LEVEL SECURITY"
    cat supabase/migrations/001_initial_schema.sql | grep -c "CREATE POLICY"
    cat supabase/migrations/001_initial_schema.sql | grep -c "organization_id IN"
  </verify>
  <done>
    "RLS enabled on all 8 tables with organization isolation policies preventing cross-tenant access"
  </done>
</task>

<task type="auto">
  <name>Task 3: Create trigger-based audit logging</name>
  <files>supabase/migrations/001_initial_schema.sql</files>
  <action>
    Add audit logging trigger function and triggers to the migration file.

    **Create audit_logs table trigger function:**
    ```sql
    CREATE OR REPLACE FUNCTION audit_trigger_function()
    RETURNS TRIGGER AS $$
    DECLARE
      audit_record audit_logs;
      org_id UUID;
    BEGIN
      -- Get organization_id from the table being modified
      EXECUTE format(
        'SELECT organization_id FROM %I WHERE id = $1',
        TG_TABLE_NAME
      ) INTO org_id USING COALESCE(NEW.id, OLD.id);

      IF TG_OP = 'DELETE' THEN
        audit_record := ROW(
          gen_random_uuid(),
          org_id,
          auth.uid(),
          TG_OP || ' ON ' || TG_TABLE_NAME,
          TG_TABLE_NAME,
          OLD.id,
          to_jsonb(OLD),
          NULL,
          NOW()
        );
        INSERT INTO audit_logs VALUES (audit_record.*);
        RETURN OLD;

      ELSIF TG_OP = 'UPDATE' THEN
        audit_record := ROW(
          gen_random_uuid(),
          org_id,
          auth.uid(),
          TG_OP || ' ON ' || TG_TABLE_NAME,
          TG_TABLE_NAME,
          NEW.id,
          to_jsonb(OLD),
          to_jsonb(NEW),
          NOW()
        );
        INSERT INTO audit_logs VALUES (audit_record.*);
        RETURN NEW;

      ELSIF TG_OP = 'INSERT' THEN
        audit_record := ROW(
          gen_random_uuid(),
          org_id,
          auth.uid(),
          TG_OP || ' ON ' || TG_TABLE_NAME,
          TG_TABLE_NAME,
          NEW.id,
          NULL,
          to_jsonb(NEW),
          NOW()
        );
        INSERT INTO audit_logs VALUES (audit_record.*);
        RETURN NEW;
      END IF;
      RETURN NULL;
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;
    ```

    **Apply triggers to business tables:**
    ```sql
    CREATE TRIGGER audit_customers
      AFTER INSERT OR UPDATE OR DELETE ON customers
      FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

    CREATE TRIGGER audit_revenue
      AFTER INSERT OR UPDATE OR DELETE ON revenue
      FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

    CREATE TRIGGER audit_activities
      AFTER INSERT OR UPDATE OR DELETE ON activities
      FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();
    ```
  </action>
  <verify>
    cat supabase/migrations/001_initial_schema.sql | grep -c "audit_trigger_function"
    cat supabase/migrations/001_initial_schema.sql | grep -c "CREATE TRIGGER audit_"
  </verify>
  <done>
    "Audit trigger function created and applied to customers, revenue, and activities tables"
  </done>
</task>

<task type="auto">
  <name>Task 4: Create indexes for RLS performance</name>
  <files>supabase/migrations/001_initial_schema.sql</files>
  <action>
    Add performance indexes for RLS policy optimization and common queries.

    **Indexes on organization_id columns** (used in all RLS policies):
    ```sql
    CREATE INDEX idx_customers_org_id ON customers(organization_id);
    CREATE INDEX idx_revenue_org_id ON revenue(organization_id);
    CREATE INDEX idx_activities_org_id ON activities(organization_id);
    CREATE INDEX idx_audit_logs_org_id ON audit_logs(organization_id);
    CREATE INDEX idx_ai_usage_org_id ON ai_usage_log(organization_id);
    ```

    **Indexes on foreign key columns:**
    ```sql
    CREATE INDEX idx_profiles_user_org ON profiles(id, organization_id);
    CREATE INDEX idx_customers_status ON customers(status) WHERE deleted_at IS NULL;
    CREATE INDEX idx_revenue_date ON revenue(date);
    CREATE INDEX idx_activities_type ON activities(type);
    CREATE INDEX idx_ai_usage_date ON ai_usage_log(date);
    ```

    **GIN index for JSONB metadata:**
    ```sql
    CREATE INDEX idx_activities_metadata ON activities USING GIN (metadata);
    ```

    **Unique index for slug:**
    ```sql
    CREATE UNIQUE INDEX idx_organizations_slug ON organizations(slug);
    ```
  </action>
  <verify>
    cat supabase/migrations/001_initial_schema.sql | grep -c "CREATE INDEX"
    cat supabase/migrations/001_initial_schema.sql | grep -c "organization_id"
  </verify>
  <done>
    "Performance indexes created on all organization_id columns and frequently queried fields"
  </done>
</task>

<task type="auto">
  <name>Task 5: Create schema reference file</name>
  <files>supabase/schema.sql</files>
  <action>
    Create `supabase/schema.sql` as a readable reference document containing the complete schema with comments.

    Include:
    - Table descriptions
    - Column purposes and constraints
    - RLS policy explanations
    - Index purposes

    This file is for documentation purposes only - use migrations for actual schema changes.
  </action>
  <verify>
    cat supabase/schema.sql | grep -c "CREATE TABLE"
    cat supabase/schema.sql | grep -c "COMMENT ON"
  </verify>
  <done>
    "supabase/schema.sql created as readable schema documentation with comments"
  </done>
</task>

<task type="auto">
  <name>Task 6: Create TypeScript type definitions</name>
  <files>lib/db/types.ts</files>
  <action>
    Create `lib/db/types.ts` with TypeScript interfaces matching the database schema.

    Include all types from RESEARCH.md section "Database Type Definitions":
    - Database interface (union of all tables)
    - Each table interface (OrganizationTable, ProfileTable, CustomerTable, etc.)
    - Selectable, Insertable, Updateable types for each table
    - Enum types for constrained columns (role, status, activity type)

    Pattern:
    ```typescript
    import {
      Generated,
      JSONColumnType,
      Selectable,
      Insertable,
      Updateable,
    } from 'kysely'

    export interface Database {
      organizations: OrganizationTable
      profiles: ProfileTable
      // ... all tables
    }

    export interface OrganizationTable {
      id: Generated<string>
      name: string
      slug: string
      created_at: Generated<Date>
      updated_at: Generated<Date>
    }

    export type Organization = Selectable<OrganizationTable>
    export type NewOrganization = Insertable<OrganizationTable>
    export type OrganizationUpdate = Updateable<OrganizationTable>

    // Repeat for each table...
    ```
  </action>
  <verify>
    cat lib/db/types.ts | grep -c "export interface"
    cat lib/db/types.ts | grep -c "export type.*Selectable"
  </verify>
  <done>
    "lib/db/types.ts created with Database interface and all table types for Kysely"
  </done>
</task>

</tasks>

<verification>
Run migration against local Supabase:
```bash
cd supabase && supabase db push
```

Verify schema:
```bash
psql $DATABASE_URL -c "\dt"
psql $DATABASE_URL -c "\d+ organizations"
```

Verify TypeScript compilation:
```bash
npx tsc --noEmit lib/db/types.ts
```
</verification>

<success_criteria>
- [ ] Migration file creates 8 tables with correct schema
- [ ] RLS enabled on all tables with organization isolation policies
- [ ] Role-based access policies for admin/member enforcement
- [ ] Audit logging triggers on business tables
- [ ] Performance indexes on organization_id columns
- [ ] TypeScript types match database schema
- [ ] TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-FOUNDATION/01-02-SUMMARY.md`
</output>
