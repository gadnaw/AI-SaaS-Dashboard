---
phase: 01-foundation
plan: "04"
type: execute
wave: 4
depends_on:
  - "01-02"
files_modified:
  - "lib/db/client.ts"
  - "lib/db/index.ts"
  - "lib/repositories/customer.repository.ts"
  - "lib/repositories/revenue.repository.ts"
  - "lib/repositories/activity.repository.ts"
  - "lib/repositories/organization.repository.ts"
  - "lib/repositories/profile.repository.ts"
autonomous: true
must_haves:
  truths:
    - "Kysely client connects to database with type-safe configuration"
    - "Repository functions provide type-safe database queries"
    - "All queries are automatically scoped to organization via getOrgContext()"
    - "TypeScript compilation succeeds with strict mode"
  artifacts:
    - path: "lib/db/client.ts"
      provides: "Kysely client configured with PostgreSQL dialect"
    - path: "lib/db/index.ts"
      provides: "Re-exports for database utilities"
    - path: "lib/repositories/customer.repository.ts"
      provides: "Type-safe customer CRUD operations"
    - path: "lib/repositories/revenue.repository.ts"
      provides: "Type-safe revenue queries"
    - path: "lib/repositories/activity.repository.ts"
      provides: "Type-safe activity queries"
  key_links:
    - from: "lib/db/client.ts"
      to: "lib/db/types.ts"
      via: "Generic type parameter for Kysely<Database>"
    - from: "lib/repositories/*.repository.ts"
      to: "lib/organizations/org-context.ts"
      via: "organizationId parameter for multi-tenant filtering"
provides_interface:
  - name: db
    type: kysely_client
    description: "Type-safe Kysely database client instance"
  - name: getCustomersByOrg
    type: function
    description: "Returns all customers for an organization"
  - name: getCustomerStats
    type: function
    description: "Returns aggregated customer statistics"
  - name: getRevenueByOrg
    type: function
    description: "Returns revenue records for an organization"
  - name: getActivitiesByOrg
    type: function
    description: "Returns activity events for an organization"
  - name: getOrganizationById
    type: function
    description: "Returns organization details by ID"
  - name: getUserProfile
    type: function
    description: "Returns user profile with organization context"
assumes_from:
  - phase: 1
    interface: Database
    usage: "Type definitions for all table queries"
---

<objective>
Create the type-safe database layer with Kysely, including client configuration and repository functions for all business tables. This wave enables Phase 2 and 3 to query the database with full TypeScript inference and automatic organization scoping.

Purpose: Type-safe database access with multi-tenant query filtering
Output: Kysely client, repository functions, and query utilities
</objective>

<execution_context>
{file:~/.config/opencode/gsd/workflows/execute-plan.md}
{file:~/.config/opencode/gsd/templates/summary.md}
</execution_context>

<context>
@.planning/phases/01-FOUNDATION/01-RESEARCH.md

# Kysely patterns from research
# - Repository pattern for each table
# - Type-safe queries with full TypeScript inference
# - Organization ID filtering in every query
# - Generated types from database introspection
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Kysely database client</name>
  <files>lib/db/client.ts</files>
  <action>
    Create `lib/db/client.ts` with Kysely PostgreSQL client configuration.

    Pattern from RESEARCH.md:
    ```typescript
    import { Kysely, PostgresDialect } from 'kysely'
    import { Pool } from 'pg'
    import { Database } from './types'

    const dialect = new PostgresDialect({
      pool: new Pool({
        connectionString: process.env.DATABASE_URL,
        max: 10,
      }),
    })

    export const db = new Kysely<Database>({
      dialect,
    })
    ```

    Note: DATABASE_URL should be set in environment (Supabase provides this in connection string format).
  </action>
  <verify>
    cat lib/db/client.ts | grep -c "Kysely"
    cat lib/db/client.ts | grep -c "PostgresDialect"
    cat lib/db/client.ts | grep -c "DATABASE_URL"
  </verify>
  <done>
    "lib/db/client.ts created with Kysely PostgreSQL dialect and connection pooling"
  </done>
</task>

<task type="auto">
  <name>Task 2: Create database index export</name>
  <files>lib/db/index.ts</files>
  <action>
    Create `lib/db/index.ts` as the main entry point for database utilities.

    Re-export all database-related exports:
    ```typescript
    export { db } from './client'
    export type { Database } from './types'
    export type { Organization, NewOrganization, OrganizationUpdate } from './types'
    export type { Profile, NewProfile, ProfileUpdate } from './types'
    export type { Customer, NewCustomer, CustomerUpdate } from './types'
    export type { Revenue, NewRevenue, RevenueUpdate } from './types'
    export type { Activity, NewActivity, ActivityUpdate } from './types'
    ```
  </action>
  <verify>
    cat lib/db/index.ts | grep -c "export"
    cat lib/db/index.ts | grep -c "from './"
  </verify>
  <done>
    "lib/db/index.ts created as central export point for database types and client"
  </done>
</task>

<task type="auto">
  <name>Task 3: Create customer repository</name>
  <files>lib/repositories/customer.repository.ts</files>
  <action>
    Create `lib/repositories/customer.repository.ts` with type-safe customer operations.

    Include functions:
    ```typescript
    import { db } from '@/lib/db/client'
    import type { Insertable, Selectable } from 'kysely'
    import type { CustomerTable } from '@/lib/db/types'

    export type Customer = Selectable<CustomerTable>
    export type NewCustomer = Insertable<CustomerTable>

    /**
     * Get all customers for an organization (excluding soft-deleted)
     */
    export async function getCustomersByOrg(orgId: string) {
      return await db
        .selectFrom('customers')
        .selectAll()
        .where('organization_id', '=', orgId)
        .where('deleted_at', 'is', null)
        .orderBy('name', 'asc')
        .execute()
    }

    /**
     * Get paginated customers for an organization
     */
    export async function getCustomersPaginated(
      orgId: string,
      page: number = 1,
      limit: number = 20
    ) {
      const offset = (page - 1) * limit
      return await db
        .selectFrom('customers')
        .selectAll()
        .where('organization_id', '=', orgId)
        .where('deleted_at', 'is', null)
        .orderBy('name', 'asc')
        .limit(limit)
        .offset(offset)
        .execute()
    }

    /**
     * Get customer by ID (organization-scoped)
     */
    export async function getCustomerById(orgId: string, customerId: string) {
      return await db
        .selectFrom('customers')
        .selectAll()
        .where('id', '=', customerId)
        .where('organization_id', '=', orgId)
        .where('deleted_at', 'is', null)
        .executeTakeFirst()
    }

    /**
     * Get customer statistics for an organization
     */
    export async function getCustomerStats(orgId: string) {
      return await db
        .selectFrom('customers')
        .select([
          sql<number>`count(*)`.as('total_customers'),
          sql<number>`sum(case when status = 'active' then 1 else 0 end)`.as('active_customers'),
          sql<number>`sum(case when status = 'churned' then 1 else 0 end)`.as('churned_customers'),
          sql<number>`sum(total_revenue)`.as('total_revenue'),
          sql<number>`avg(total_revenue)`.as('avg_revenue'),
        ])
        .where('organization_id', '=', orgId)
        .where('deleted_at', 'is', null)
        .executeTakeFirst()
    }

    /**
     * Create a new customer
     */
    export async function createCustomer(customer: NewCustomer) {
      return await db
        .insertInto('customers')
        .values(customer)
        .returningAll()
        .executeTakeFirstOrThrow()
    }

    /**
     * Update a customer (soft-deletes by setting deleted_at)
     */
    export async function softDeleteCustomer(customerId: string) {
      return await db
        .updateTable('customers')
        .set({ deleted_at: new Date() })
        .where('id', '=', customerId)
        .execute()
    }
    ```
  </action>
  <verify>
    cat lib/repositories/customer.repository.ts | grep -c "export async function"
    cat lib/repositories/customer.repository.ts | grep -c "organization_id"
  </verify>
  <done>
    "lib/repositories/customer.repository.ts created with type-safe CRUD operations"
  </done>
</task>

<task type="auto">
  <name>Task 4: Create revenue repository</name>
  <files>lib/repositories/revenue.repository.ts</files>
  <action>
    Create `lib/repositories/revenue.repository.ts` with type-safe revenue queries.

    Include functions:
    ```typescript
    import { db } from '@/lib/db/client'
    import type { Insertable, Selectable } from 'kysely'
    import type { RevenueTable } from '@/lib/db/types'

    export type Revenue = Selectable<RevenueTable>
    export type NewRevenue = Insertable<RevenueTable>

    /**
     * Get all revenue for an organization
     */
    export async function getRevenueByOrg(orgId: string) {
      return await db
        .selectFrom('revenue')
        .selectAll()
        .where('organization_id', '=', orgId)
        .orderBy('date', 'desc')
        .execute()
    }

    /**
     * Get revenue by date range
     */
    export async function getRevenueByDateRange(
      orgId: string,
      startDate: Date,
      endDate: Date
    ) {
      return await db
        .selectFrom('revenue')
        .selectAll()
        .where('organization_id', '=', orgId)
        .where('date', '>=', startDate)
        .where('date', '<=', endDate)
        .orderBy('date', 'desc')
        .execute()
    }

    /**
     * Get revenue grouped by category
     */
    export async function getRevenueByCategory(orgId: string) {
      return await db
        .selectFrom('revenue')
        .select([
          'category',
          sql<number>`sum(amount)`.as('total'),
          sql<number>`count(*)`.as('count'),
        ])
        .where('organization_id', '=', orgId)
        .groupBy('category')
        .execute()
    }

    /**
     * Get revenue by customer
     */
    export async function getRevenueByCustomer(orgId: string, customerId: string) {
      return await db
        .selectFrom('revenue')
        .selectAll()
        .where('organization_id', '=', orgId)
        .where('customer_id', '=', customerId)
        .orderBy('date', 'desc')
        .execute()
    }

    /**
     * Get revenue totals for organization
     */
    export async function getRevenueTotals(orgId: string) {
      return await db
        .selectFrom('revenue')
        .select([
          sql<number>`sum(amount)`.as('total_revenue'),
          sql<number>`count(*)`.as('transaction_count'),
          sql<number>`avg(amount)`.as('avg_transaction'),
        ])
        .where('organization_id', '=', orgId)
        .executeTakeFirst()
    }

    /**
     * Get monthly revenue trend (last N months)
     */
    export async function getMonthlyRevenueTrend(orgId: string, months: number = 12) {
      return await db
        .selectFrom('revenue')
        .select([
          sql<string>`to_char(date, 'YYYY-MM')`.as('month'),
          sql<number>`sum(amount)`.as('revenue'),
        ])
        .where('organization_id', '=', orgId)
        .groupBy(sql`to_char(date, 'YYYY-MM')`)
        .orderBy('month', 'desc')
        .limit(months)
        .execute()
    }

    /**
     * Create revenue record
     */
    export async function createRevenue(revenue: NewRevenue) {
      return await db
        .insertInto('revenue')
        .values(revenue)
        .returningAll()
        .executeTakeFirstOrThrow()
    }
    ```
  </action>
  <verify>
    cat lib/repositories/revenue.repository.ts | grep -c "export async function"
    cat lib/repositories/revenue.repository.ts | grep -c "organization_id"
  </verify>
  <done>
    "lib/repositories/revenue.repository.ts created with date range and aggregation queries"
  </done>
</task>

<task type="auto">
  <name>Task 5: Create activity repository</name>
  <files>lib/repositories/activity.repository.ts</files>
  <action>
    Create `lib/repositories/activity.repository.ts` with type-safe activity/event queries.

    Include functions:
    ```typescript
    import { db } from '@/lib/db/client'
    import type { Insertable, Selectable } from 'kysely'
    import type { ActivityTable } from '@/lib/db/types'

    export type Activity = Selectable<ActivityTable>
    export type NewActivity = Insertable<ActivityTable>

    /**
     * Get all activities for an organization
     */
    export async function getActivitiesByOrg(orgId: string, limit: number = 100) {
      return await db
        .selectFrom('activities')
        .selectAll()
        .where('organization_id', '=', orgId)
        .orderBy('created_at', 'desc')
        .limit(limit)
        .execute()
    }

    /**
     * Get activities by type
     */
    export async function getActivitiesByType(
      orgId: string,
      type: 'signup' | 'purchase' | 'churn' | 'login' | 'export'
    ) {
      return await db
        .selectFrom('activities')
        .selectAll()
        .where('organization_id', '=', orgId)
        .where('type', '=', type)
        .orderBy('created_at', 'desc')
        .execute()
    }

    /**
     * Get activities by customer
     */
    export async function getCustomerActivities(orgId: string, customerId: string) {
      return await db
        .selectFrom('activities')
        .selectAll()
        .where('organization_id', '=', orgId)
        .where('customer_id', '=', customerId)
        .orderBy('created_at', 'desc')
        .execute()
    }

    /**
     * Get activity counts by type
     */
    export async function getActivityCountsByType(orgId: string) {
      return await db
        .selectFrom('activities')
        .select([
          'type',
          sql<number>`count(*)`.as('count'),
        ])
        .where('organization_id', '=', orgId)
        .groupBy('type')
        .execute()
    }

    /**
     * Create activity record
     */
    export async function createActivity(activity: NewActivity) {
      return await db
        .insertInto('activities')
        .values(activity)
        .returningAll()
        .executeTakeFirstOrThrow()
    }

    /**
     * Get recent activity count
     */
    export async function getRecentActivityCount(orgId: string, days: number = 7) {
      const startDate = new Date()
      startDate.setDate(startDate.getDate() - days)

      return await db
        .selectFrom('activities')
        .select(sql<number>`count(*)`.as('count'))
        .where('organization_id', '=', orgId)
        .where('created_at', '>=', startDate)
        .executeTakeFirst()
    }
    ```
  </action>
  <verify>
    cat lib/repositories/activity.repository.ts | grep -c "export async function"
    cat lib/repositories/activity.repository.ts | grep -c "organization_id"
  </verify>
  <done>
    "lib/repositories/activity.repository.ts created with filtering and aggregation queries"
  </done>
</task>

<task type="auto">
  <name>Task 6: Create organization and profile repositories</name>
  <files>lib/repositories/organization.repository.ts</files>
  <action>
    Create `lib/repositories/organization.repository.ts`:
    ```typescript
    import { db } from '@/lib/db/client'
    import type { Insertable, Selectable } from 'kysely'
    import type { OrganizationTable } from '@/lib/db/types'

    export type Organization = Selectable<OrganizationTable>
    export type NewOrganization = Insertable<OrganizationTable>

    export async function getOrganizationById(orgId: string) {
      return await db
        .selectFrom('organizations')
        .selectAll()
        .where('id', '=', orgId)
        .executeTakeFirst()
    }

    export async function getOrganizationBySlug(slug: string) {
      return await db
        .selectFrom('organizations')
        .selectAll()
        .where('slug', '=', slug)
        .executeTakeFirst()
    }

    export async function updateOrganization(
      orgId: string,
      data: Partial<Organization>
    ) {
      return await db
        .updateTable('organizations')
        .set({ ...data, updated_at: new Date() })
        .where('id', '=', orgId)
        .returningAll()
        .executeTakeFirst()
    }
    ```

    Create `lib/repositories/profile.repository.ts`:
    ```typescript
    import { db } from '@/lib/db/client'
    import type { Selectable } from 'kysely'
    import type { ProfileTable } from '@/lib/db/types'

    export type Profile = Selectable<ProfileTable>

    export async function getUserProfile(userId: string) {
      return await db
        .selectFrom('profiles')
        .selectAll()
        .where('id', '=', userId)
        .executeTakeFirst()
    }

    export async function getProfilesByOrg(orgId: string) {
      return await db
        .selectFrom('profiles')
        .selectAll()
        .where('organization_id', '=', orgId)
        .execute()
    }

    export async function updateProfile(userId: string, data: Partial<Profile>) {
      return await db
        .updateTable('profiles')
        .set({ ...data, updated_at: new Date() })
        .where('id', '=', userId)
        .returningAll()
        .executeTakeFirst()
    }
    ```
  </action>
  <verify>
    cat lib/repositories/organization.repository.ts | grep -c "export async function"
    cat lib/repositories/profile.repository.ts | grep -c "export async function"
  </verify>
  <done>
    "lib/repositories/organization.repository.ts and profile.repository.ts created"
  </done>
</task>

<task type="auto">
  <name>Task 7: Create repositories index</name>
  <files>lib/repositories/index.ts</files>
  <action>
    Create `lib/repositories/index.ts` as the main export point for all repositories.

    ```typescript
    export { db } from '@/lib/db/client'

    // Customer repository
    export {
      getCustomersByOrg,
      getCustomersPaginated,
      getCustomerById,
      getCustomerStats,
      createCustomer,
      softDeleteCustomer,
      type Customer,
      type NewCustomer,
    } from './customer.repository'

    // Revenue repository
    export {
      getRevenueByOrg,
      getRevenueByDateRange,
      getRevenueByCategory,
      getRevenueByCustomer,
      getRevenueTotals,
      getMonthlyRevenueTrend,
      createRevenue,
      type Revenue,
      type NewRevenue,
    } from './revenue.repository'

    // Activity repository
    export {
      getActivitiesByOrg,
      getActivitiesByType,
      getCustomerActivities,
      getActivityCountsByType,
      createActivity,
      getRecentActivityCount,
      type Activity,
      type NewActivity,
    } from './activity.repository'

    // Organization repository
    export {
      getOrganizationById,
      getOrganizationBySlug,
      updateOrganization,
      type Organization,
      type NewOrganization,
    } from './organization.repository'

    // Profile repository
    export {
      getUserProfile,
      getProfilesByOrg,
      updateProfile,
      type Profile,
    } from './profile.repository'
    ```
  </action>
  <verify>
    cat lib/repositories/index.ts | grep -c "from './"
  </verify>
  <done>
    "lib/repositories/index.ts created as central export for all repositories"
  </done>
</task>

</tasks>

<verification>
Verify TypeScript compilation:
```bash
npx tsc --noEmit --strict
```

Test database connection (requires DATABASE_URL):
```bash
npx ts-node -e "import { db } from './lib/db/client'; console.log('Database client created')"
```

Verify all repositories export functions:
```bash
grep -r "export async function" lib/repositories/ | wc -l
```
Expected: 20+ exported functions
</verification>

<success_criteria>
- [ ] Kysely client connects to database with proper configuration
- [ ] Repository functions provide type-safe queries with full TypeScript inference
- [ ] All queries filter by organization_id for multi-tenant isolation
- [ ] TypeScript strict mode passes
- [ ] All repositories are exported from central index
</success_criteria>

<output>
After completion, create `.planning/phases/01-FOUNDATION/01-04-SUMMARY.md`
</output>
